# 设计模式总结
[toc]
## OO基础
1. 抽象：不关注行为等具体，只将对象行为属性等，抽象成一个名词
2. 封装：将属性，行为封装成独立起来
3. 多态：在同一个大类下有不同的属性相同产物，通过控制大类属性行为，去控制具体的产物属性行为。
4. 继承：子类继承父类所拥有的所有属性，行为，并可进行拓展，加强现有属性行为

## OO原则
1. 封装变化：
找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
2. 针对接口编程，不针对实现编程
3. 多用组合，少用继承
4. 为交互对象之间的松耦合设计而努力
5. 开放关闭原则：
对扩展开放，对修改关闭
6. 依赖抽象，不依赖具体类
7. 最少知识原则
只和朋友交谈
8. 好莱坞原则
别调用我们，我们会调用你
9. 单一原则：
一个类应该只有一个引起变化的原因

## 模式的定义
* 在某情景下，针对某问题的某种解决方案

## 模式解析
模式|描述
:-:|:-:
装饰者|包装一个对象，以提供新的行为
状态|封装了基于状态的行为，并使用委托在行为之间切换
迭代器|在对象的集合之中游走，而不暴露集合的实现
外观|简化一群类的接口
策略|封装可以互换的行为，而不暴露集合的实现
代理|包装对象，以控制对此对象的访问
工厂方法|有子类决定要创建的具体类是哪一个
适配器|封装对象，并提供不同的接口
观察者|让对象能够在状态改变时被通知
模板方法|游资雷剧顶如何实现一个算法中的步骤
组合|客户用一致的方式处理对象集合和单个对象
单例|确保有且只有一个对象被创建
抽象工厂|允许客户创建对象的家族，而无需指定他们的具体类
命令|封装请求成为对象
### 1. 策略模式
* 定义算法簇，分别封装起来，让它们之间可以互相替换
1. 封装变化，变化的行为或属性封装成不同的算法簇
2. 针对接口编程，不针对实现编程：通过变化的行为实现同一个接口，
3. 多用组合，少用继承：可以取代原有类中的接口实现不同的实际行为

### 2. 观察者模式
* 在对象之间定义一对多的依赖，当一个对象改变状态时，其他对象会收到通知。
1. 封装变化：主题的状态，被通知者数量，类型是变化的
2. 针对接口编程，不针对实现编程：通过实现统一的通知接口，通知具体的每个观察者
3. 多用组合，少用继承：利用一对多的组合关系将不同的主题和观察者，组合在一起
4. 松耦合：通过动态的绑定，一对多的关系，主题本身和观察者没有强相关

### 3. 装饰者模式
* 动态的将责任附加到对象上。
1. 组合：为被装饰对象，装饰不同的装饰类，从而组合拓展不同的功能
2. 开放关闭原则：原类静止修改，但是可以增加行为
3. 松耦合：通过套用不同的装饰，达到拓展行为。

### 4. 工厂模式
* 抽象工厂模式：提供一个接口用于创建相关或依赖对象的家族，不需要明确指定具体类。
* 工厂方法模式：定义一个创建对象接口，将类的实例化推迟到子类具体实例化
1. 依赖抽象，不依赖具体，将工厂模式中，具有想通的一大类具体考虑，不需要去依赖具体

### 5. 单件模式
* 确保类只有一个实例，并提供全局方法

### 6. 命令模式
* 将请求封装成对象。
1. 封装变化：将每个不同的命令都封装成一个类
2. 多用组合：将每个命令与不同的使用命令，形成一个组合

### 7. 适配器模式
* 适配器模式：将一个接口转换成客户期望的另一个接口
* 外观模式：提供了一个统一的接口，用来访问子系统中的一群接口
1. 最少知识原则：适配器，和外观都只和最少的类联系

### 8. 模板方法
* 在一个方法中定义一个算法的骨架，而将一些变化的步骤延迟到子类中。
1. 封装变化：将一个算法骨架可能不同算法的部分延迟到子类封装
2. 多用组合，少用继承：通过不同的子类实现不同算法的部分，从而达到不同的结果
3. 好莱坞原则：算法骨架调用算法具体实现方法，具体实现方法不能访问上级

### 9. 迭代器模式
* 迭代器：提供一种方法顺序访问一个聚合对象中的各个元素，而由不暴露其内部的对象
* 组合模式： 允许你将对象组成树形结构来表示“整体/部分”的层次结构。
1. 单一原则：迭代器负责提供集合的顺序访问行为。
2. 开放关闭原则：通过继承或者装饰的方式可以扩展出此行为

### 10. 状态模式
* 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类
1. 封装变化：封装每一个对应不同的状态
2. 组合：通过切换不同的状态类，达到一个组合切换，状态的目的

### 11. 代理模式
* 为另一个对象提供一个替身或占位符以访问这个对象

### 12. 复合模式
* 结合两种或者以上的模式，组成一个解决方案，解决一再发生的一般问题

### 13. 桥接模式
* 对象和可变行为同时抽象，取公共部分桥接，
例如：鸭子会叫，鹅也会叫，鸭子和鹅都属于动物，叫也是不同的行为。
1. 封装变化：将具体的变化实现封装
2. 组合：通过不同的具体实现，以及不同的属性对象进行组合，达到不同的效果
3. 松耦合：在具体实现在具体互相组合实际的对象与行为

### 14. 生成器模式
* 封装一个产品的构造过程，并允许按步骤构造。

### 15. 责任链模式
* 通过链的形式，将一个请求逐级通过每个链的节点
1. 封装变化：每个节点的过滤条件封装
2. 组合：通过每个节点的过滤产生不同的过滤效果
3. 松耦合：将发送者和接收者解耦，因为在责任链中，往往不知道命令由哪个节点所处理
4. 单一原则： 一个节点只做链中的一个过滤条件

### 16. 蝇量
* 让某一个实例能提供多个虚拟实例。

### 17. 解释器
* 为语言创建解释器
例如：Python，其实是C语言实现的。
JAVA底层是C++实现
汇编语言其实是机器语言指令的封装品

### 18. 中介者
* 集中控制对象之间的沟通和控制方式
1. 松耦合：需要相关联的对象全部解耦，只需与中介者耦合即可

### 19. 备忘录
* 让对象返回之前的状态

### 20. 原型模式
* clone已有实例

### 21. 访问者模式
* 不破坏组合的情况下，为一个对象组合增加新行为
1. 开放关闭原则：组合修改禁止，新行为扩展添加，虽然破坏了封装性