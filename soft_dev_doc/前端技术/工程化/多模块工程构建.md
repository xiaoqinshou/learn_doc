## monorepo ç®¡ç†æ–¹å¼

### lerna

- ä¸€ä¸ªéå¸¸æˆç†Ÿçš„æ¨¡å—åŒ–ç®¡ç†å·¥å…·
- [å®˜æ–¹æ–‡æ¡£](https://lerna.js.org/docs/getting-started)

### å®‰è£…

```sh
# å…¨å±€å®‰è£…åç»­ä¸ç”¨åŠ  npx å‘½ä»¤
npm install lerna -g
```

### åˆå§‹åŒ–

```shell
# åˆå§‹åŒ– lerna é¡¹ç›®
$ npx lerna init --packages="packages/*"
# æ·»åŠ ç¼“å­˜
$ npx lerna add-caching
```

### æ„å»ºå­æ¨¡å—

- å»ºç»„å» npm å®˜ç½‘å»ºç»„å³å¯

```sh
# åˆ›å»ºä¸€ä¸ªå•ç‹¬çš„åŒ…æ¨¡å—
npx lerna create form-core
# æŒ‰ç…§æç¤ºè¾“å…¥å‘½ä»¤å³å¯
# åŒ…åè®¾ç½®ä¸º @w-lab/form-coreï¼Œåé¢ç”¨å¾—åˆ°
# åˆ›å»ºä¸€ä¸ªæ–‡æ¡£æ¨¡å—ï¼Œwebç«¯ å¼•å…¥
npx lerna create docs
```

### æŸ¥çœ‹å­é¡¹ç›®

```sh
npx lerna list
# or
npx lerna ls
```

### å®‰è£…ä¾èµ–

```sh
# å®‰è£…å†…éƒ¨ä¾èµ–
pnpm add -D typescript --filter=@w-lab/form-core
pnpm add react react-dom --filter=@w-lab/form-core

# å®‰è£…å…¨å±€ä¾èµ–
pnpm add -D @types/react -w
```

### å¸¸ç”¨å‘½ä»¤

- [å®˜ç½‘](https://lerna.nodejs.cn/docs/api-reference/commands)

### é…ç½®æ¨¡å—

- é…ç½®ä¸¤ä¸ªæ¨¡å—åšæ¼”ç¤º

```sh
npx lerna create form-core
npx lerna create docs
```

### åˆ›å»ºç»Ÿä¸€æ‰“åŒ…è„šæœ¬

- å…ˆæ ¹ç›®å½•ä¸‹åˆ›å»º srcirpts/virtualHtmlPlugin.ts åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿ Html æ’ä»¶ï¼Œç”¨äºè¿è¡Œæ‰“åŒ…æ—¶ç”¨äºå„ä¸ªå­é¡¹ç›®è‡ªåŠ¨åŠ è½½ html æ¨¡æ¿

```ts
import { type ViteDevServer } from "vite";

type HtmlTemplateOptions = { title: string; favicon: string };

// devæ¨¡å¼å¿…é¡»åŠ è¿™æ®µä»£ç ï¼Œå¦åˆ™æ— æ³•çƒ­æ›´æ–°å’ŒåŠ è½½ç»„ä»¶
const devServerHtml = `
<script type="module">
  import RefreshRuntime from "/@react-refresh"
  RefreshRuntime.injectIntoGlobalHook(window)
  window.$RefreshReg$ = () => {}
  window.$RefreshSig$ = () => (type) => type
  window.__vite_plugin_react_preamble_installed__ = true
</script>
<script type="module" src="/@vite/client"></script>
`;

// virtualHtmlPlugin.ts
// public html tamplate
const htmlTemplate = (
  { title, favicon }: HtmlTemplateOptions,
  isDev: boolean = false
) =>
  `
<!DOCTYPE html>
<html lang="en">
  <head>
    ${isDev || devServerHtml}
    <meta charset="UTF-8" />
    <link rel="icon" href="${favicon}" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>${title}</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html>
`.trim();

export default function virtualHtmlPlugin(config: HtmlTemplateOptions) {
  const buildHtml = htmlTemplate(config);
  const devHtml = htmlTemplate(config, true);
  return {
    name: "virtual-html",
    configureServer(server: ViteDevServer) {
      server.middlewares.use((req, res, next) => {
        if (req.url === "/" || req.url === "/index.html") {
          res.statusCode = 200;
          res.setHeader("Content-Type", "text/html");
          res.end(buildHtml);
          return;
        }
        next();
      });
    },
    resolveId(id: string) {
      // å½“è¯·æ±‚ index.html æ—¶ï¼Œè¿”å›ä¸€ä¸ªè‡ªå®šä¹‰çš„æ ‡è¯†ç¬¦
      if (id === "index.html") {
        return id;
      }
    },
    load(id: string) {
      if (id === "index.html") {
        // è¿”å›å†…å­˜ä¸­çš„ HTML å­—ç¬¦ä¸²
        return devHtml;
      }
    },
  };
}
```

- æ¨¡æ¿ title,favicon é…ç½®ï¼Œäº¤ç”±ç¯å¢ƒå˜é‡ç®¡ç†,åœ¨å¯¹åº”çš„æ¨¡å—ä¸‹åˆ›å»ºç¯å¢ƒå˜é‡æ–‡ä»¶.env, æ³¨å…¥å˜é‡å³å¯

```txt
APP_TITLE = æµ‹è¯•æ ‡é¢˜
APP_FAVICON = /favicon.ico
```

- å†åˆ›å»º srcirpts/build.ts ç»Ÿä¸€çš„ vite build è„šæœ¬

```ts
// build.ts ç»Ÿä¸€buildè„šæœ¬ï¼Œè¿è¡Œä½ç½®åœ¨å¯¹åº”æ¨¡å—çš„ç›®å½•ä¸‹é…ç½®
import { build, defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import dts from "vite-plugin-dts";
import yargs, { type ArgumentsCamelCase } from "yargs";
import path from "path";
import fs from "fs/promises";
// ts-node å¯åŠ¨å¿…é¡»å¸¦.tsåç¼€æ‰ä¼šç¼–è¯‘æ–‡ä»¶æ‰§è¡Œ
// @ts-ignore
import virtualHtmlPlugin from "./virtualHtmlPlugin.ts";

async function run(
  argv: ArgumentsCamelCase<{
    mode: "lib" | "app";
    outDir: string;
    verbose: boolean;
  }>
) {
  const { mode, outDir, verbose } = argv;
  // å‡è®¾ monorepo çš„ç»“æ„æ˜¯ï¼šæ ¹ç›®å½•/packages/<pkgName>
  const pkgDir = process.cwd();
  const pkgJsonPath = path.join(pkgDir, "package.json");
  const pkgJson = JSON.parse(await fs.readFile(pkgJsonPath, "utf8"));

  // é»˜è®¤å…¥å£æ–‡ä»¶ä¸º src/index.ts
  const entry = path.join(pkgDir, "src", "index.ts");

  // ç»Ÿä¸€çš„åŸºç¡€é…ç½®
  const baseConfig = {
    root: pkgDir,
    resolve: {
      alias: {},
    },
    build: {
      sourcemap: true,
      outDir: path.resolve(process.cwd(), outDir),
    },
  };

  let config;
  if (mode === "lib") {
    // åº“æ¨¡å¼é…ç½®ï¼šæ”¯æŒç”Ÿæˆ ESM/CJS æ ¼å¼ï¼Œå¤–éƒ¨ä¾èµ–ï¼ˆæ¯”å¦‚ reactï¼‰ä¸æ‰“åŒ…è¿›æ¥
    config = defineConfig({
      ...baseConfig,
      plugins: [
        react(),
        // ç”Ÿæˆç±»å‹å£°æ˜æ–‡ä»¶ï¼ˆå¦‚æœéœ€è¦ï¼‰
        dts({
          insertTypesEntry: true,
          // è¿™é‡Œçš„ entry å¯ä»¥é…ç½®ä¸ºä½ çš„å…¥å£ç±»å‹æ–‡ä»¶
          entryRoot: path.join(pkgDir, "src"),
        }),
      ],
      build: {
        ...baseConfig.build,
        lib: {
          entry,
          name: pkgJson.name,
          // fileName: (format) => `${pkgJson.name}.${format}.js`,
        },
        rollupOptions: {
          // å£°æ˜å¤–éƒ¨ä¾èµ–ï¼Œä¸å°†å…¶æ‰“åŒ…åˆ°åº“ä¸­
          external: ["react", "react-dom"],
          output: {
            globals: {
              react: "React",
              "react-dom": "ReactDOM",
            },
          },
        },
      },
    });
  } else {
    // è¯»å–ç¯å¢ƒå˜é‡çš„å€¼
    const { APP_TITLE, APP_FAVICON } = process.env;
    // Web åº”ç”¨æ¨¡å¼é…ç½®ï¼šé€šå¸¸ä¸éœ€è¦ç”Ÿæˆåº“æ¨¡å¼ç›¸å…³çš„é€‰é¡¹
    config = defineConfig({
      ...baseConfig,
      root: pkgDir,
      plugins: [
        react(),
        virtualHtmlPlugin({
          title: APP_TITLE || "Default Title",
          favicon: APP_FAVICON || "/favicon.ico",
        }),
      ],
      build: {
        ...baseConfig.build,
        rollupOptions: {
          input: "index.html",
        },
        // å¯ä»¥æ·»åŠ åº”ç”¨ç‰¹å®šçš„é…ç½®
      },
    });
  }

  if (verbose) {
    console.log("ä½¿ç”¨çš„ Vite é…ç½®ï¼š");
    console.log(JSON.stringify(config, null, 2));
  }

  // è°ƒç”¨ Vite API å¼€å§‹æ„å»º
  await build(config);
  console.log(`æ„å»ºæˆåŠŸï¼è¾“å‡ºç›®å½•ï¼š${baseConfig.build.outDir}`);
}

// è§£æå‘½ä»¤è¡Œå‚æ•°
yargs(process.argv.slice(2))
  .command(
    "$0 <mode>",
    "build <mode>",
    (yargs) => {
      return yargs
        .positional("mode", {
          type: "string",
          choices: ["lib", "app"],
          default: "lib",
          description: "æ„å»ºæ¨¡å¼ï¼šlib æ„å»ºä¸ºåº“ï¼ˆnpm åŒ…ï¼‰ï¼Œapp æ„å»ºä¸º Web åº”ç”¨",
        })
        .option("outDir", {
          type: "string",
          default: "./build",
          description: "æ‰“åŒ…åè¾“å‡ºè·¯å¾„",
        })
        .option("verbose", {
          type: "boolean",
          default: false,
          description: "æ˜¯å¦æ˜¾ç¤ºè¯¦ç»†æ—¥å¿—",
        });
    },
    run
  )
  .help()
  .strict()
  .version(false)
  .parse();
```

- å†åˆ›å»º srcirpts/dev.ts ç»Ÿä¸€çš„ vite dev è„šæœ¬

```ts
// dev.ts
import { createServer, defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import fs from "fs/promises";
import yargs, { type ArgumentsCamelCase } from "yargs";
// ts-node å¯åŠ¨å¿…é¡»å¸¦.tsåç¼€æ‰ä¼šç¼–è¯‘æ–‡ä»¶æ‰§è¡Œ
// @ts-ignore
import virtualHtmlPlugin from "./virtualHtmlPlugin.ts";
import dotenv from "dotenv";

// åŠ è½½ç¯å¢ƒå˜é‡
dotenv.config();

async function run(
  argv: ArgumentsCamelCase<{
    port: number;
    proxyUri: string;
  }>
) {
  const pkgDir = process.cwd();
  const pkgJsonPath = path.join(pkgDir, "package.json");
  const pkgJson = JSON.parse(await fs.readFile(pkgJsonPath, "utf8"));
  const pkgName = pkgJson.name;
  // è¯»å–ç¯å¢ƒå˜é‡çš„å€¼
  const { APP_TITLE, APP_FAVICON } = process.env;

  // app æ¨¡å¼éœ€è¦ç¡®ä¿ pkgDir ä¸‹æœ‰ index.html æ–‡ä»¶
  const config = defineConfig({
    root: pkgDir,
    plugins: [
      react(),
      virtualHtmlPlugin({
        title: APP_TITLE || "Default Title",
        favicon: APP_FAVICON || "/favicon.ico",
      }),
    ],
    server: {
      port: argv.port,
      open: true,
    },
    build: {
      outDir: path.resolve(process.cwd(), "build", pkgName),
    },
  });
  const server = await createServer(config);
  await server.listen();
  console.info();
  console.info(
    "  \x1b[32m%s\x1b[0m  Local:   \x1b[36m%s\x1b[0m",
    "âœ",
    `http://localhost:${argv.port}`
  );
}

// è§£æå‘½ä»¤è¡Œå‚æ•°
yargs(process.argv.slice(1))
  .command(
    "$0 <mode>",
    "build <mode>",
    (yargs) => {
      return yargs
        .option("port", {
          type: "number",
          default: "5173",
          description: "è¿è¡Œç«¯å£",
        })
        .option("proxyUri", { type: "string", description: "ä»£ç†åœ°å€" });
    },
    run
  )
  .help()
  .strict()
  .version(false)
  .parse();
```

### ä½¿ç”¨ç»Ÿä¸€è„šæœ¬

```sh
# æŒ‰ç…§æ–‡ä»¶è·¯å¾„åœ¨å¯¹åº”çš„æ¨¡å—åŠ å…¥ package.json ä¸­æ·»åŠ æ‰“åŒ…å‘½ä»¤
# form-core
"build": "ts-node ../../scripts/build.ts lib",
# docs
"build": "ts-node ../scripts/build.ts app",
"dev": "ts-node ../scripts/dev.ts",
# docs å¼•å…¥ form-core
"@w-lab/form-core": "workspace:^",
```

- åœ¨ form-core æ¨¡å—åŠ å…¥æµ‹è¯•ä»£ç 

```tsx
"use client";
const TestCompontent = () => {
  return <div>Test tag</div>;
};
export { TestCompontent };
```

- åœ¨ docs æ¨¡å—ä¸­ä½¿ç”¨è¯¥ä»£ç 

```tsx
import { TestCompontent } from "@w-lab/form-core";
import React from "react";
import ReactDOM from "react-dom/client";

const app: null | Element = document.getElementById("root"); // é¿å… id é‡å¤å¯¼è‡´å¾®åº”ç”¨æŒ‚è½½å¤±è´¥

ReactDOM.createRoot(app as Element).render(
  <React.StrictMode>
    <TestCompontent />
  </React.StrictMode>
);
```

- åˆ†åˆ«æ‰“åŒ…ï¼Œæµ‹è¯•ä¸€ä¸‹ï¼Œæœ€ç»ˆæ•ˆæœï¼ŒæŸ¥çœ‹ä¸€ä¸‹ docs çš„æ‰“åŒ…å¼•å…¥æ•ˆæœ
  ![](./images/2025-03-12-11-06-34.png)

- è¿è¡Œä¸€ä¸‹å¼€å‘ç¯å¢ƒçš„æœåŠ¡å™¨è¯•è¯•
  ![](./images/2025-03-12-18-57-59.png)
  ![](./images/2025-03-12-18-57-43.png)
- å…¶ä¸­çš„`(node:83898) ExperimentalWarning` è­¦å‘Šå…³ä¸æ‰ï¼Œts-node æ¯”è¾ƒæ–°è¿™ä¸ªæµ‹è¯•åŠŸèƒ½æ— æ³•å…³é—­

/App.tsx åº”ç”¨å±‚ç»Ÿä¸€å…¥å£æ–‡ä»¶
import { DarkTheme, LightTheme, ThemeProvider } from "@w-lab/tailwind-theme";
import React, { Suspense } from "react";
import { AuthProvider } from "./common/auth/AuthProvider";
import { BrowserRouter, HashRouter, Route, Routes } from "react-router";
import { routes } from './routes/common';

const App = ({ isSsr = false }: { isSsr: boolean }) => {
  const CurrentRouter = isSsr ? BrowserRouter : HashRouter
  return <ThemeProvider themeGroup={{ light: LightTheme, dark: DarkTheme, custom: LightTheme }}>
    <AuthProvider>
      <CurrentRouter>
        <Suspense fallback={<div>Loading...</div>}>
          <Routes>
            {routes.map((r) => (
              <Route path={r.path} element={r.element} key={r.path} />
            ))}
          </Routes>
        </Suspense>
      </CurrentRouter>
    </AuthProvider>
  </ThemeProvider>
}

export default App

/entry-server.tsx æœåŠ¡ç«¯å…¥å£æ–‡ä»¶
import React, { Suspense } from 'react';
import { renderToPipeableStream, renderToString } from 'react-dom/server';
import App from '../App';
import { StaticRouter } from 'react-router';
import { routes } from '../routes/common';
import { AuthProvider } from '../common/auth/AuthProvider';
import '../common/i18n/i18n';
import { DarkTheme, LightTheme, ThemeProvider } from '@w-lab/tailwind-theme';

// SSR æ¸²æŸ“å‡½æ•°ï¼Œç”±ä½ çš„æœåŠ¡å™¨è°ƒç”¨
export const render = (
  url: string,
  manifest: Record<string, string[]>,
) => {
  const matched = routes.find(r => r.path === url);
  const helmetContext = {
    helmet: {
      title: 'title',
      meta: ''
    }
  }
  const app = (
    <App isSsr={true} />
  );
  const html = renderToPipeableStream(app)
  return html
}

/server.ts SSRå¼€å‘æˆ–ç”Ÿäº§æ—¶å¯åŠ¨è„šæœ¬
// server.ts
import express from 'express';
import fs from 'fs/promises';
import path from 'path';
import type { ViteDevServer } from 'vite';
import virtualHtmlPlugin, { htmlTemplate } from './plugins/virtualHtmlPlugin.ts';
import dotenv from 'dotenv';
import { getWorkspaceRoot } from './utils/index.ts';
import injectTailwindPlugin from './plugins/injectTailwindPlugin.ts';
import tailwindcss from '@tailwindcss/vite';
import react from '@vitejs/plugin-react';
import { env } from 'process';

// åŠ è½½ç¯å¢ƒå˜é‡
dotenv.config();

function getBasePath(raw: string) {
  try {
    // å¦‚æœ raw æ˜¯å®Œæ•´çš„ URLï¼Œå°±è¿”å›å®ƒçš„ pathname
    return new URL(raw).pathname;
  } catch {
    // ä¸æ˜¯ URLï¼Œé‚£å°±å‡è®¾å®ƒæœ¬èº«å°±æ˜¯ä¸€ä¸ªè·¯å¾„ï¼Œç›´æ¥è¿”å›
    return raw;
  }
}

const isProd = process.env.NODE_ENV === 'production';
const port = Number(process.env.PORT) || 8000;
const rawBase = process.env.BASE || '/';

const base = getBasePath(rawBase);

const app = express();

let vite: ViteDevServer | undefined;
let template: string;
let ssrRender: (
  url: string,
  manifest: Record<string, string[]>,
) => Promise<{
  head?: string;
  html: string;
}>;

let ssrManifest: Record<string, string[]> = {};

async function init() {
  if (!isProd) {
    // å¼€å‘æ¨¡å¼
    const { createServer } = await import('vite');
    // æ³¨å…¥tailwindcss
    // è¯»å– Tailwind ç”Ÿæˆçš„å…¨å±€ CSS è·¯å¾„
    const workspaceRoot = getWorkspaceRoot();
    const tailwindCssPath = path.join(workspaceRoot, 'tailwindcss', 'dev.css');

    vite = await createServer({
      server: { middlewareMode: true },
      mode: 'ssr',
      resolve: {
        alias: {
          '@w-lab/form-core': path.resolve(workspaceRoot, 'packages/form-core/src'),
          '@w-lab/wui-material': path.resolve(workspaceRoot, 'packages/wui-material/src'),
          '@w-lab/tailwind-theme': path.resolve(workspaceRoot, 'packages/tailwind-theme/src'),
        },
      },
      plugins: [
        injectTailwindPlugin(tailwindCssPath), // æŠŠ Tailwind CSS link æ³¨å…¥åˆ° template
        tailwindcss(), // Vuetify Tailwind æ’ä»¶
        react(), // React æ’ä»¶
        virtualHtmlPlugin({
          title: process.env.APP_TITLE as string,
          favicon: process.env.APP_FAVICON as string,
          isDev: true,
          mode: 'ssr',
        }),
      ],
      appType: 'custom',
      base,
    });
    app.use(vite.middlewares);
  } else {
    const pkgDir = process.cwd();
    // ç”Ÿäº§æ¨¡å¼ï¼šé¢„åŠ è½½æ¨¡æ¿ã€Manifest ä¸ SSR handler
    const clientDist = path.resolve(pkgDir, 'build/client');
    const serverDist = path.resolve(pkgDir, 'build/server');

    // 1. HTML æ¨¡æ¿
    template = await fs.readFile(path.join(clientDist, 'index.html'), 'utf-8');

    // 2. SSR manifest
    const manifestJson = await fs.readFile(
      path.join(clientDist, '.vite/ssr-manifest.json'),
      'utf-8',
    );
    ssrManifest = JSON.parse(manifestJson);

    // 3. SSR æ¸²æŸ“å‡½æ•°
    const { render } = await import(path.join(serverDist, 'entry-server.mjs'));
    ssrRender = render;

    // 4. é™æ€èµ„æº
    const compression = (await import('compression')).default;
    const sirv = (await import('sirv')).default;
    app.use(compression());
    app.use(base, sirv(clientDist, { extensions: [] }));
  }
}

app.get(base, async (req, res) => {
  try {
    const url = req.originalUrl.replace(base, '/');

    if (!isProd) {
      // æ¯æ¬¡è¯·æ±‚éƒ½é‡æ–°åŠ è½½æœ€æ–°ä»£ç 
      let devHtml = await vite!.transformIndexHtml(url, '');
      const { render } = await vite!.ssrLoadModule('/src/server/entry-server.tsx');
      const { head, html } = await render(url, {});
      res
        .status(200)
        .set({ 'Content-Type': 'text/html' })
        .send(devHtml.replace('<!--app-head-->', head ?? '').replace('<!--app-html-->', html));
    } else {
      // ç”Ÿäº§ç¯å¢ƒï¼šä½¿ç”¨ç¼“å­˜
      const { head, html } = await ssrRender(req.url, ssrManifest);
      res
        .status(200)
        .set({ 'Content-Type': 'text/html' })
        .send(template.replace('<!--app-head-->', head ?? '').replace('<!--app-html-->', html));
    }
  } catch (e: any) {
    if (!isProd) vite?.ssrFixStacktrace(e);
    console.error(e.stack);
    res.status(500).send(e.stack);
  }
});

init()
  .then(() => {
    app.listen(port, () => {
      console.log(
        `ğŸš€ Server running at http://localhost:${port} [${isProd ? 'production' : 'development'}]`,
      );
    });
  })
  .catch((err) => {
    console.error('âŒ Server start failed:', err);
    process.exit(1);
  });
