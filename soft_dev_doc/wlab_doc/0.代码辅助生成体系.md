## 前言
* 由于写重复代码是一件非常糟糕的事情，所以在框架中植入对应的工具用于减轻开发人员的成本

### 工具思路
* 沿用 mermaid 画图工具来对 数据库表进行建模，然后通过解析的方式自动生成对应的，java的`entity`、`repository`、`Service` 代码

* 额外创造一个接口设计语言用于生成，对应的JAVA的`Controller`、`DTO`等模板代码、前端的 `from`、`request`、`table`代码.

## 使用方式
### mermaid 代码生成
* 单模块只有一个数据库文件，所以统一嵌入了工程 gradle 的任务中
```gradle
task codegen(type: EntityCodegenTask) {
    group = "codegen"
    // 只填参数，不用跨项目 dependsOn
    input = "$projectDir/src/main/resources/mermaid.mmd"
    out   = "$projectDir/src/main" // 生成器会拼接 /java
    pkg   = { -> project.group }
    type  = "jpa"
}
```
* 默认统一读取模块下的 /src/main/resources/mermaid.mmd 文件
直接调用 codegen.codegen任务即可

* 所有文件都是，如果有对应文件则自动跳过生成

### api design 代码生成
* 使用以下语言规范
```apid
API: insert
DESC: 插入字典类型
PATH: /insert
METHOD: PUT

# 包装容器|基础对象， list | page | type, 其中type类型指的是前面是基础对象
REQUEST DictTypeInsert object
# 请求数据格式 内容体都是 字段名 类型 字段约束条件若干 描述
  name string required >0 <64 '字典名称'
  description string '描述'
  code string required >0 <64 /^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)*$/ '字典编码'
  active bool '是否启用' =true
  sort int '排序顺序' =0

# 包装容器|基础对象，list | page | type, 其中type类型指的是前面是基础对象
RESPONSE DictType page
# 内容体都是 字段名 类型 描述
  id uuid '主键'
  name string '字典类型名称'
  description string '描述'
  code string '字典类型编码'
  systemBuilt bool '是否系统内置'
  active bool '是否启用'
  sort int '排序顺序'

RESPONSE DictType object
# 分割接口的分割符
---
# 接口名称
API: list
# 接口描述
DESC: 获取字典类型列表
# 接口路径
PATH: /list
# 请求方式
METHOD: GET
# 接口标签，用于spring doc 分类
TAGS: dict-type, list

# 包装容器|基础对象， list | page | type, 其中type类型指的是前面是基础对象
REQUEST DictTypeFilter page
# 请求数据格式
  name string '字典类型名称'
  code string '字典类型编码'

# 返回数据格式 模型名称 包装容器|基础对象， list | page | type, 其中type类型指的是前面是基础对象
RESPONSE DictType page
# 内容体都是 字段名 类型 描述
  id uuid '主键'
  name string '字典类型名称'
  description string '描述'
  code string '字典类型编码'
  systemBuilt bool '是否系统内置'
  active bool '是否启用'
  sort int '排序顺序'
```
