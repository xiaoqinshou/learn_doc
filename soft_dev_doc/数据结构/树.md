# 树
[toc]

## 基本定义
1. 定义树的一种自然方式是递归的方式
2. 一棵树是一些节点的集合
3. 这些集合可以是空集；若不是空集，则树又称作**根(root)**节点，以及 0 个或多个非空的子树组成
4. 子树中每一棵的**根**都被来自**根(root)**的一条有向**边(edge)**所连接
5. 每棵子树的**根**叫做**根(root)**的**儿子(child)**，而**根(root)**是每一棵子树的**父亲(parent)**
6. 一棵树是 N 个节点和 N - 1 条边的集合，其中一个节点交做**根**
7. 每条边都将某个节点链接到它的父亲，除去根节点外每个节点都有一个父亲
8. 每个节点可以有任意多个儿子，也可能是0个儿子
9. 没有儿子的节点称为**树叶(leaf)**
10. 相同父亲的节点称为**兄弟(siblings)**
11. 根据 7、8、9、10 可定义出 **祖父(grandparent)** 和 **孙子(grandchild)** 节点关系
12. 从节点 $n_1$ 到 $n_k$ 的 **路径(path)** 定义为节点 $n_1,n_2,...,n_k$ 的一个序列，使得对于 $1\leq i<k$ 节点 $n_i$ 是 $n_{i+1}$ 的父亲。这了路径的 **长(length)** 是该路径上的边的数量，即 $k-1$
13. 每个节点到它子有一条长为零的路径
14. 在一棵树种从根到每个节点恰好值有一条路径
15. 对任意节点 $n_i$, $n_i$ 的 **深度(depth)** 为从根到 $n_i$ 的唯一路径的长
16. 对任意节点 $n_i$, $n_i$ 的 **高(height)** 为从 $n_i$ 到一片树叶的最长路径
17. 如果存在 $n_1$ 到 $n_2$ 的一条路径，那么 $n_1$ 是 $n_2$ 的一位 **祖先(ancestor)** 而 $n_2$ 是 $n_1$ 的一个 **后裔(descendant)** ；如果 $n_1\neq n_2$ 那么 $n_1$ 是 $n_2$ 的 **真祖先(proper ancestor)** 而 $n_2$ 是 $n_1$ 的 **真后裔(proper descendant)**

### 一般的树
```plantuml
circle root
circle child_1
circle child_2
circle child_3
circle child_4
circle child_5
circle child_6

root -- child_1
root -- child_2
root -- child_3
root -- child_4
root -- child_5
root -- child_6
```

### 一棵树
```plantuml
circle A
circle B
circle C
circle D
circle E
circle F
circle G
circle H
circle I
circle J
circle K
circle L
circle M
circle N
circle P
circle Q

A -- B
A -- C
A -- D
A -- E
A -- F
A -- G
D -- H
E -- I
E -- J
J -- P
J -- Q
F -- K
F -- L
F -- M
G -- N
```

### 树的实现
> 实现树的一种方法可以是在每一个节点除外数据还有一些链，使得该节点的每一个儿子节点都有一个链指向他。然而，由于每个节点的儿子数可以变化很大并且事先不知道，因此在数据结构中建立到各个**子节点**的直接链接是不可行的，因为会产生大量的浪费空间。
* 一般树的数据结构表现形式
```java
class TreeNode{
  Object element;// 本身节点
  TreeNode firstChild;// 第一儿子节点 没有则为null
  TreeNode nextSibling;// 下一兄弟节点 没有则为null
}
```
* 由上个点的数据结构可，构想出，放入程序中的一棵树的数据形式。
```plantuml
circle A
circle B
circle C
circle D
circle E
circle F
circle G
circle H
circle I
circle J
circle K
circle L
circle M
circle N
circle P
circle Q

A -- B
B - C
C - D
D - E
E - F
F - G
D -- H
E -- I
I - J
J -- P
P - Q
F -- K
K - L
L - M
G -- N
```

### 树的应用
> 典型的应用就是 UNIX 等常用的操作系统中的目录结构。从根路径下展开的形式，就不展开一一赘述。

### 树的遍历
* 先序遍历：先遍历中间节点，再遍历左节点，最后遍历右节点。
  例如：上面所提到的树的先序遍历就是：`ABCDHEIJPQFKLMGN`
  用途：上一节所提到的可以用于遍历，Unix 系统的文件夹路径
```java
// 伪代码,传入树的根节点
public void print(TreeNode treeNode){
  if(treeNode == null){
    return;
  }
  System.out.println(treeNode.element);
  print(treeNode.firstChild);
  print(treeNode.nextSbiling);
}
```
<br/>

* 后序遍历：先遍历左边节点，再遍历右边节点，最后遍历中间节点。
  例如：上面所提到的树的先序遍历就是：`BDHDIPQJEKLMFNGA`
  用途：上一节所提到的可以用于逆序遍历，Unix 系统的文件夹大小计算文件夹大小等。
```java
// 伪代码,传入树的根节点
public void print(TreeNode treeNode){
  if(treeNode == null){
    return;
  }
  print(treeNode.firstChild);
  System.out.println(treeNode.element);
  print(treeNode.nextSbiling);
}
```

## 二叉树(binary tree)
### 概述
> 二叉树是一棵特殊的树, 其中每个节点都不能有多于两个的子节点。

### 实现
* 二叉树数据结构
```java
class BinaryNode{
  Object element;
  BinaryNode left;
  BinaryNode Right;
}
```

### 遍历方式
* 左序遍历/先序遍历：同上一节树的遍历方式
<br/>

* 右序遍历/后序遍历：同上
<br/>

* 中序遍历：先遍历左节点，再遍历中间节点(父节点)
