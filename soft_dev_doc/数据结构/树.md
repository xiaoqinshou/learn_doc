# 树
[toc]

## 基本定义
1. 定义树的一种自然方式是递归的方式
2. 一棵树是一些节点的集合
3. 这些集合可以是空集；若不是空集，则树又称作**根(root)**节点，以及 0 个或多个非空的子树组成
4. 子树中每一棵的**根**都被来自**根(root)**的一条有向**边(edge)**所连接
5. 每棵子树的**根**叫做**根(root)**的**儿子(child)**，而**根(root)**是每一棵子树的**父亲(parent)**
6. 一棵树是 N 个节点和 N - 1 条边的集合，其中一个节点交做**根**
7. 每条边都将某个节点链接到它的父亲，除去根节点外每个节点都有一个父亲
8. 每个节点可以有任意多个儿子，也可能是0个儿子
9. 没有儿子的节点称为**树叶(leaf)**
10. 相同父亲的节点称为**兄弟(siblings)**
11. 根据 7、8、9、10 可定义出 **祖父(grandparent)** 和 **孙子(grandchild)** 节点关系
12. 从节点 $n_1$ 到 $n_k$ 的 **路径(path)** 定义为节点 $n_1,n_2,...,n_k$ 的一个序列，使得对于 $1\leq i<k$ 节点 $n_i$ 是 $n_{i+1}$ 的父亲。这了路径的 **长(length)** 是该路径上的边的数量，即 $k-1$
13. 每个节点到它子有一条长为零的路径
14. 在一棵树种从根到每个节点恰好值有一条路径
15. 对任意节点 $n_i$, $n_i$ 的 **深度(depth)** 为从根到 $n_i$ 的唯一路径的长
16. 对任意节点 $n_i$, $n_i$ 的 **高(height)** 为从 $n_i$ 到一片树叶的最长路径
17. 如果存在 $n_1$ 到 $n_2$ 的一条路径，那么 $n_1$ 是 $n_2$ 的一位 **祖先(ancestor)** 而 $n_2$ 是 $n_1$ 的一个 **后裔(descendant)** ；如果 $n_1\neq n_2$ 那么 $n_1$ 是 $n_2$ 的 **真祖先(proper ancestor)** 而 $n_2$ 是 $n_1$ 的 **真后裔(proper descendant)**

### 一般的树
```plantuml
circle root
circle child_1
circle child_2
circle child_3
circle child_4
circle child_5
circle child_6

root -- child_1
root -- child_2
root -- child_3
root -- child_4
root -- child_5
root -- child_6
```

### 一棵树
```plantuml
circle A
circle B
circle C
circle D
circle E
circle F
circle G
circle H
circle I
circle J
circle K
circle L
circle M
circle N
circle P
circle Q

A -- B
A -- C
A -- D
A -- E
A -- F
A -- G
D -- H
E -- I
E -- J
J -- P
J -- Q
F -- K
F -- L
F -- M
G -- N
```

### 树的实现
> 实现树的一种方法可以是在每一个节点除外数据还有一些链，使得该节点的每一个儿子节点都有一个链指向他。然而，由于每个节点的儿子数可以变化很大并且事先不知道，因此在数据结构中建立到各个**子节点**的直接链接是不可行的，因为会产生大量的浪费空间。
* 一般树的数据结构表现形式
```java
class TreeNode{
  Object element;// 本身节点
  TreeNode firstChild;// 第一儿子节点 没有则为null
  TreeNode nextSibling;// 下一兄弟节点 没有则为null
}
```
* 由上个点的数据结构可，构想出，放入程序中的一棵树的数据形式。
```plantuml
circle A
circle B
circle C
circle D
circle E
circle F
circle G
circle H
circle I
circle J
circle K
circle L
circle M
circle N
circle P
circle Q

A -- B
B - C
C - D
D - E
E - F
F - G
D -- H
E -- I
I - J
J -- P
P - Q
F -- K
K - L
L - M
G -- N
```

### 树的应用
> 典型的应用就是 UNIX 等常用的操作系统中的目录结构。从根路径下展开的形式，就不展开一一赘述。

### 树的遍历
* 先序遍历：先遍历中间节点，再遍历左节点，最后遍历右节点。
  例如：上面所提到的树的先序遍历就是：`ABCDHEIJPQFKLMGN`
  用途：上一节所提到的可以用于遍历，Unix 系统的文件夹路径
```java
// 伪代码,传入树的根节点
public void print(TreeNode treeNode){
  if(treeNode == null){
    return;
  }
  System.out.println(treeNode.element);
  print(treeNode.firstChild);
  print(treeNode.nextSbiling);
}
```
<br/>

* 后序遍历：先遍历左边节点，再遍历右边节点，最后遍历中间节点。
  例如：上面所提到的树的先序遍历就是：`BDHDIPQJEKLMFNGA`
  用途：上一节所提到的可以用于逆序遍历，Unix 系统的文件夹大小计算文件夹大小等。
```java
// 伪代码,传入树的根节点
public void print(TreeNode treeNode){
  if(treeNode == null){
    return;
  }
  print(treeNode.firstChild);
  System.out.println(treeNode.element);
  print(treeNode.nextSbiling);
}
```

## 二叉树(binary tree)
### 概述
> 二叉树是一棵特殊的树, 其中每个节点都不能有多于两个的子节点。

### 性质
> 一棵平均二叉树的深度要比节点数 N 小得多，分析表明其平均深度为 $O(\sqrt N)$, 对于特殊类型的二叉树，即**二叉查找树(binary search tree)**,其深度平均值是 $O(\log N)$, 最坏情况的二叉树深度可以达到 $N-1$
### 实现
* 二叉树数据结构
```java
class BinaryNode{
  Object element;
  BinaryNode left;
  BinaryNode Right;
}
```

### 遍历方式
* 左序遍历/先序遍历：同上一节树的遍历方式
<br/>

* 右序遍历/后序遍历：同上
<br/>

* 中序遍历：先遍历左节点，再遍历中间节点(父节点)

### 表达式树
&emsp;很有趣的一种树的运用方式。
&emsp;假设存在以下计算式：$(a+b*c)+((d*e+f)*g)$，把操作符当做根节点，操作数当做叶子节点，可以看出，这其实就是一颗二叉树的中序遍历后的结果。
* 且通过压栈的方式可以把它凑成一颗表达式树，然后通过后续遍历就可以得到，计算机能够看得懂的，运算计算式。
* 如下图，凑合着看，排不了顺序，而且节点还不能重复
```plantuml
circle a
circle b
circle c
circle d
circle e
circle f
circle g
circle "*_1"
circle "+_1"
circle "*_2"
circle "+_2"
circle "*_3"
circle "+_3"

[+_1] -- [+_2]
[+_1] -- [*_1]
[+_2] -- a
[+_2] -- [*_2]
[*_2] -- b
[*_2] -- c
[*_1] -- [+_3]
[*_1] -- g
[+_3] -- [*_3]
[+_3] -- f
[*_3] -- d
[*_3] -- e
```

## 二叉查找树
&emsp;假设树中的每个节点存储一项数据。假设他们存储的都是整数。使每个节点  X它的左子树中的所有值小于X中的值，而使它的右子树大于X中的值。
* 二叉查找树的平均深度是 $O(\log N)$

### 遍历
从根节点开始，需要查找值，大于该节点往右走，如果小于该节点往左走，如果等于该节点输出。未找到继续重复本步骤，直至遍历完整棵树。

### 插入
按照遍历的套路进行查找，找到最后的节点，再根据大小插入该节点的 左孩子或者右孩子上

### 删除
* 删除分为三种情况
1. 删除叶子节点，直接删除即可
2. 当节点有一个儿子，由当前删除节点的父节点直接绕过该节点，去指向它的唯一儿子节点，然后删除该节点
3. 当节点有两个儿子时，一般删除策略是用它的右子树中的最小节点，代替当前节点，并递归的删除那个节点(如果最小节点有0，1，2个节点就重复第1，2，3步骤即可)。

### 懒惰删除(lazy deletion)
* 当一个节点要被删除时，它仍留在书中，只是被标记删除。
1. 该方式对有重复项的树就，很常用，只需要在节点的频率树域减1即可
2. 如果有被删除的项重新插入了，这样也避免了重新分配一个新单元的开销
3. 如果树实际存在的节点和‘被标记删除’的节点数相同，那么树的深度预计只上升一个小的常数($\log(2n)-\log{n}$ = 1)

### 平均情况分析
* 一棵树的所有节点的深度和称为 **内部路径长**(internal path length)。
* 令 $D(N)$ 是具有 $N$ 个 节点的某棵树 $T$ 的内部路径长，$D(1)=0$。
一棵 $N$ 节点树由一棵 $i$ 节点的左子树和一棵($N-i-1$) 节点的右子树以及深度0处的一个根节点组成，其中 $0\leq i<N$, $D(i)$ 为跟的左子树内部路径长。但在原树中，由于多了一个根节点，所以这些节点都要加深一度，同理对右子树也成立。因此得到以下关系式：
$D(N)=D(i)+D(N-i-1)+N-1$
$\because 0<i\leq N-1$
$\therefore 左右子树的平均内部路径长为: \frac{\sum_{j=0}^{N-1}D(j)}{N}$
$D(N)=\frac{2}{N}(\sum^{N-1}_{j=0}D(j))+N-1$
求解过程可参考$D(N)=2D(\frac{N}{2})+N-1$ 这个递归式求解。具体求解过程暂时不会，以后记得就补充。
最后可得到平均值为 $D(N)=O(N\log N)$，因此任意节点预期的深度为 $O(\log N)$
* 因为在N次插入二叉查找树后，容易造成对二叉查找树的失衡，在根节点 左子树过大，或右子树过大的情况，这时候二叉查找树的最效率将降低
## AVL 树
&emsp;AVL(Adelson-Velskii 和 Landis)树是 **带有平衡条件(balance condition)** 的二叉树。这个平衡条件必须要容易保持，而且它保证树的深度须是 $O(\log N)$。每个节点的左子树和右子树高度最多差1，当超过1时，则此AVL树失衡

### 修正方式
#### 单旋转
* 个人称之为特殊的双旋转，左左旋转或者右右旋转。
* 假设有如下的一颗 AVL 树
![](./images/2020-08-01-15-16-54.png)
* 当插入 6 时，AVL 树的平衡就被破坏
![](./images/2020-08-01-15-27-37.png)
* 此时显而易见的修正方式就是断开5和8，连上5和7，8作为7的右子节点，搞定（这种操作称之为7-8的单旋转）。
![](./images/2020-08-01-15-31-57.png)

* 试着想象从一颗空树依次插入3、2、1、4、5、6、7。通过AVL 单旋转修正后的二叉树，和普通二叉查找树插入后的区别。

#### 双旋转
* 由上面提到的树插入而成的 AVL 树。
![](./images/2020-08-01-15-51-51.png)
* 现在依次倒叙插入8-16
* 插入16简单，不涉及 AVL 树的破坏。接着插入15。
![](./images/2020-08-01-16-09-27.png)
* 这时候就要来一 7 为起节点的 右-左双旋转了(个人跟倾向于理解为两次单旋转，先旋转16-15，在旋转7-15,就等于右左双旋转了)。
* 双旋转时的操作。断开6-7 连上6-15 连上15-7 连上 15-16 断开 7-16 断开 16-15
![](./images/2020-08-01-16-31-59.png)

* 插入 14 时 节点6-15-7 凑成 右-左双旋转。进行旋转
* 然后插入 13 会在根节点造成一个不平衡，经过单旋转修正。
* 之后不再举例，最后结果会生成如下树：
![](./images/2020-08-01-17-19-29.png)

#### 伪代码
```java
public class AvlTree<AnyType>{

  // 平衡阈值
  private static final int ALLOWED_IMBALACE = 1;

  // 树节点
  private class AvlNode<AnyType>{
    AnyType node;
    AvlNode<AnyType> left;
    AvlNode<AnyType> right;
    int height;

    // 新建根节点
    AvlNode(AnyType node){
      this(node,null,null);
    }

    // 新建节点
    AvlNode(AnyType node, AvlNode<AnyType> lt, AvlNode<AnyType> rt){
      this.node = node;
      this.left = lt;
      this.right = rt;
      this.height = 0;
    }
  }

  // 获取节点高度
  private int nodeHeight(AvlNode<Type> node){
    return node==null?-1:node.height;
  }

  // 插入节点
  private AvlNode<AnyType> insert(AvlNode<AnyType> node, AnyType data){
    if(node == null){
      // 节点不存在，初始化
      return new AvlNode(data);
    }
    int resultNum = data.compareTo(node.node);
    if(resultNum > 0){
      node.right = insert(node.right, data);
    }
    if(resultNum < 0){
      node.left = insert(node.left, data);
    }
    return blance(node);
  }

  // 自平衡
  private AvlNode<AnyType> blance(AvlNode<AnyType> node){
    if(node == null){
      return node;
    }
    // 左子树 比 右子树高度要高
    if(nodeHeight(node.left) - nodeHeight(node.right) > ALLOWED_IMBALACE){
      if(nodeHeight(node.left.left)>=nodeHeight(node.left.right)){
        // 左子树的左节点高度 高于 左子树左节点的右子树 高度情况就只需要左左旋转，也就是只要单旋转就能使这部分节点保持平衡
        node = rotateWithLeftChild(node);
      }else{
        // 反之就是左子树的左节点的 右子树高于 左子树左节点的左子树，这种情况就是 左右旋转了，就是双旋转。
        node = doubleWithLeftChild(node);
      }
    }
    // 与左子树同理
    if(nodeHeight(node.right) - nodeHeight(node.left) > ALLOWED_IMBALACE){
      if(nodeHeight(node.right.right)>=nodeHeight(node.right.left)){
        // 右右旋转，也就是只要单旋转就能使这部分节点保持平衡
        node = rotateWithRightChild(node);
      }else{
        // 右左旋转 需要用到双旋转。
        node = doubleWithRightChild(node);
      }
    }
  }

  private AvlNode<ANyType> rotateWithLeftChild(AvlNode<AnyType> node){
    AvlNode<AnyType> nodeLeft = node.left;
    node.left = nodeLeft.right;
    nodeLeft.right = node;

  }
}
```
