# 树
[toc]

## 基本定义
1. 定义树的一种自然方式是递归的方式
2. 一棵树是一些节点的集合
3. 这些集合可以是空集；若不是空集，则树又称作**根(root)**节点，以及 0 个或多个非空的子树组成
4. 子树中每一棵的**根**都被来自**根(root)**的一条有向**边(edge)**所连接
5. 每棵子树的**根**叫做**根(root)**的**儿子(child)**，而**根(root)**是每一棵子树的**父亲(parent)**
6. 一棵树是 N 个节点和 N - 1 条边的集合，其中一个节点交做**根**
7. 每条边都将某个节点链接到它的父亲，除去根节点外每个节点都有一个父亲
8. 每个节点可以有任意多个儿子，也可能是0个儿子
9. 没有儿子的节点称为**树叶(leaf)**
10. 相同父亲的节点称为**兄弟(siblings)**
11. 根据 7、8、9、10 可定义出 **祖父(grandparent)** 和 **孙子(grandchild)** 节点关系
12. 从节点 $n_1$ 到 $n_k$ 的 **路径(path)** 定义为节点 $n_1,n_2,...,n_k$ 的一个序列，使得对于 $1\leq i<k$ 节点 $n_i$ 是 $n_{i+1}$ 的父亲。这了路径的 **长(length)** 是该路径上的边的数量，即 $k-1$
13. 每个节点到它子有一条长为零的路径
14. 在一棵树种从根到每个节点恰好值有一条路径
15. 对任意节点 $n_i$, $n_i$ 的 **深度(depth)** 为从根到 $n_i$ 的唯一路径的长
16. 对任意节点 $n_i$, $n_i$ 的 **高(height)** 为从 $n_i$ 到一片树叶的最长路径
17. 如果存在 $n_1$ 到 $n_2$ 的一条路径，那么 $n_1$ 是 $n_2$ 的一位 **祖先(ancestor)** 而 $n_2$ 是 $n_1$ 的一个 **后裔(descendant)** ；如果 $n_1\neq n_2$ 那么 $n_1$ 是 $n_2$ 的 **真祖先(proper ancestor)** 而 $n_2$ 是 $n_1$ 的 **真后裔(proper descendant)**

### 一般的树
```plantuml
circle root
circle child_1
circle child_2
circle child_3
circle child_4
circle child_5
circle child_6

root -- child_1
root -- child_2
root -- child_3
root -- child_4
root -- child_5
root -- child_6
```

### 一棵树
```plantuml
circle A
circle B
circle C
circle D
circle E
circle F
circle G
circle H
circle I
circle J
circle K
circle L
circle M
circle N
circle P
circle Q

A -- B
A -- C
A -- D
A -- E
A -- F
A -- G
D -- H
E -- I
E -- J
J -- P
J -- Q
F -- K
F -- L
F -- M
G -- N
```

### 树的实现
> 实现树的一种方法可以是在每一个节点除外数据还有一些链，使得该节点的每一个儿子节点都有一个链指向他。然而，由于每个节点的儿子数可以变化很大并且事先不知道，因此在数据结构中建立到各个**子节点**的直接链接是不可行的，因为会产生大量的浪费空间。
* 一般树的数据结构表现形式
```java
class TreeNode{
  Object element;// 本身节点
  TreeNode firstChild;// 第一儿子节点 没有则为null
  TreeNode nextSibling;// 下一兄弟节点 没有则为null
}
```
* 由上个点的数据结构可，构想出，放入程序中的一棵树的数据形式。
```plantuml
circle A
circle B
circle C
circle D
circle E
circle F
circle G
circle H
circle I
circle J
circle K
circle L
circle M
circle N
circle P
circle Q

A -- B
B - C
C - D
D - E
E - F
F - G
D -- H
E -- I
I - J
J -- P
P - Q
F -- K
K - L
L - M
G -- N
```

### 树的应用
> 典型的应用就是 UNIX 等常用的操作系统中的目录结构。从根路径下展开的形式，就不展开一一赘述。

### 树的遍历
* 先序遍历：先遍历中间节点，再遍历左节点，最后遍历右节点。
  例如：上面所提到的树的先序遍历就是：`ABCDHEIJPQFKLMGN`
  用途：上一节所提到的可以用于遍历，Unix 系统的文件夹路径
```java
// 伪代码,传入树的根节点
public void print(TreeNode treeNode){
  if(treeNode == null){
    return;
  }
  System.out.println(treeNode.element);
  print(treeNode.firstChild);
  print(treeNode.nextSbiling);
}
```
<br/>

* 后序遍历：先遍历左边节点，再遍历右边节点，最后遍历中间节点。
  例如：上面所提到的树的先序遍历就是：`BDHDIPQJEKLMFNGA`
  用途：上一节所提到的可以用于逆序遍历，Unix 系统的文件夹大小计算文件夹大小等。
```java
// 伪代码,传入树的根节点
public void print(TreeNode treeNode){
  if(treeNode == null){
    return;
  }
  print(treeNode.firstChild);
  System.out.println(treeNode.element);
  print(treeNode.nextSbiling);
}
```

## 二叉树(binary tree)
### 概述
> 二叉树是一棵特殊的树, 其中每个节点都不能有多于两个的子节点。

### 性质
> 一棵平均二叉树的深度要比节点数 N 小得多，分析表明其平均深度为 $O(\sqrt N)$, 对于特殊类型的二叉树，即**二叉查找树(binary search tree)**,其深度平均值是 $O(\log N)$, 最坏情况的二叉树深度可以达到 $N-1$
### 实现
* 二叉树数据结构
```java
class BinaryNode{
  Object element;
  BinaryNode left;
  BinaryNode Right;
}
```

### 遍历方式
* 左序遍历/先序遍历：同上一节树的遍历方式
<br/>

* 右序遍历/后序遍历：同上
<br/>

* 中序遍历：先遍历左节点，再遍历中间节点(父节点)

### 表达式树
&emsp;很有趣的一种树的运用方式。
&emsp;假设存在以下计算式：$(a+b*c)+((d*e+f)*g)$，把操作符当做根节点，操作数当做叶子节点，可以看出，这其实就是一颗二叉树的中序遍历后的结果。
* 且通过压栈的方式可以把它凑成一颗表达式树，然后通过后续遍历就可以得到，计算机能够看得懂的，运算计算式。
* 如下图，凑合着看，排不了顺序，而且节点还不能重复
```plantuml
circle a
circle b
circle c
circle d
circle e
circle f
circle g
circle "*_1"
circle "+_1"
circle "*_2"
circle "+_2"
circle "*_3"
circle "+_3"

[+_1] -- [+_2]
[+_1] -- [*_1]
[+_2] -- a
[+_2] -- [*_2]
[*_2] -- b
[*_2] -- c
[*_1] -- [+_3]
[*_1] -- g
[+_3] -- [*_3]
[+_3] -- f
[*_3] -- d
[*_3] -- e
```

## 二叉查找树
&emsp;假设树中的每个节点存储一项数据。假设他们存储的都是整数。使每个节点  X它的左子树中的所有值小于X中的值，而使它的右子树大于X中的值。
* 二叉查找树的平均深度是 $O(\log N)$

### 遍历
从根节点开始，需要查找值，大于该节点往右走，如果小于该节点往左走，如果等于该节点输出。未找到继续重复本步骤，直至遍历完整棵树。

### 插入
按照遍历的套路进行查找，找到最后的节点，再根据大小插入该节点的 左孩子或者右孩子上

### 删除
* 删除分为三种情况
1. 删除叶子节点，直接删除即可
2. 当节点有一个儿子，由当前删除节点的父节点直接绕过该节点，去指向它的唯一儿子节点，然后删除该节点
3. 当节点有两个儿子时，一般删除策略是用它的右子树中的最小节点，代替当前节点，并递归的删除那个节点(如果最小节点有0，1，2个节点就重复第1，2，3步骤即可)。

### 懒惰删除(lazy deletion)
* 当一个节点要被删除时，它仍留在书中，只是被标记删除。
1. 该方式对有重复项的树就，很常用，只需要在节点的频率树域减1即可
2. 如果有被删除的项重新插入了，这样也避免了重新分配一个新单元的开销
3. 如果树实际存在的节点和‘被标记删除’的节点数相同，那么树的深度预计只上升一个小的常数($\log(2n)-\log{n}$ = 1)

### 平均情况分析
* 一棵树的所有节点的深度和称为 **内部路径长**(internal path length)。
* 令 $D(N)$ 是具有 $N$ 个 节点的某棵树 $T$ 的内部路径长，$D(1)=0$。
一棵 $N$ 节点树由一棵 $i$ 节点的左子树和一棵($N-i-1$) 节点的右子树以及深度0处的一个根节点组成，其中 $0\leq i<N$, $D(i)$ 为跟的左子树内部路径长。但在原树中，由于多了一个根节点，所以这些节点都要加深一度，同理对右子树也成立。因此得到以下关系式：
$D(N)=D(i)+D(N-i-1)+N-1$
$\because 0<i\leq N-1$
$\therefore 左右子树的平均内部路径长为: \frac{\sum_{j=0}^{N-1}D(j)}{N}$
$D(N)=\frac{2}{N}(\sum^{N-1}_{j=0}D(j))+N-1$
求解过程可参考$D(N)=2D(\frac{N}{2})+N-1$ 这个递归式求解。具体求解过程暂时不会，以后记得就补充。
最后可得到平均值为 $D(N)=O(N\log N)$，因此任意节点预期的深度为 $O(\log N)$
## AVL 树
&emsp;AVL(Adelson-Velskii 和 Landis)树是 **带有平衡条件(balance condition)** 的二叉树。这个平衡条件必须要容易保持，而且它保证树的深度须是 $O(\log N)$。
1. 每个节点的左子树和右子树高度最多差1
