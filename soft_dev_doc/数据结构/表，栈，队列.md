[toc]
# 抽象数据类型
&emsp;**抽象数据类型(abstract data type, ADT)**是带有一组操作的一些对象的集合。属于数学上的抽象。对于集合 `ADT`, 可以有添加(add)，删除(remove)，包含(cotains)，合并(union)，查找(find)的一些操作。
# 表
## 表的基础概念
&emsp;一组数据的集合称为一般的表，该集合的大小是该集合最大能放入的元素容量，当改集合为空时，此特殊的表称之为空表。这是数学上的概念。
* 假设有以下集合：$\{A_0,A_1,A_2,...,A_n\}$
1. 用表的概念来解释就是，该表大小为 n + 1
2. 除空表外，**表中每个位置的元素都是有顺序的**，不同于集合无序
3. 每一位又读作：$A_i$ 后继 $A_{i-1}$ $i<n$ 或者是 $A_{i-1}$ 前驱 $A_i$ $i>0$
4. 其中表中第一个元素和最后一个元素，没有对应的前驱元素和后继元素

## 表的实现方式
### 简单数组实现方式
```java
// 简单的一个集合表
int[] arr = new int[10]

// 但是 JAVA 数组对表大小必须声明，在实际使用时，基本不可能明确界定表的大小
// 所以一般会需要进行扩大
int[] newArr = new int[arr.length * 2]
for(int i=0; i<arr.length; i++){
    newArr[i]=arr[i]
}
arr = newArr;
```
* 对于这种形式的基本表，进行数据的查找，可以直接通过数组的下标，对于查找数据来说，简直完美，查找数据以线性时间被执行。
* 删除，插入简直是噩梦，做出以下分析：
    假设最坏情况对于大小为 N 的表(满载情况)，进行删除第一个位置的元素，则剩下（n-1）个元素，都得向前移动。
    添加同理。
* 所以插入和删除，数组表无法满足性能，则又产生了一种表**链表**

### 链表
&emsp;犹如链条的链表就产生了，它是把集合中的每个元素进行分块存储，使的`ADT`表，在插入，删除上更加灵活。并且每个部分都可以进行移动。

#### 简单链表(单链表linked list)
```plantuml
[A_0]
[A_1]
[A_2]
[A_3]
[A_4]
[A_5]
A_0->A_1
A_1->A_2
A_2->A_3
A_3->A_4
A_4->A_5
A_5->null
```
* 由图可知链表是由一系列节点组成，这些节点单向相连，并且不必在内存中相连，可以分散存储。
1. 每个节点均含有表元素 `A_0` 和包含到下一个元素的**链(地址)(link)**，我们称之为 **next链**，最后一个 **next链** 保存 null。
2. 删除其中一个节点时将该节点的前驱节点直接指向该节点的后继节点即可，然后将本节 next 指向 null
3. 插入：将新节点的next 指向要插入的位置的节点的后继节点，再将该位置的前驱节点的next 指向该新节点即可
4. 查找必须从头结点开始往下找。
#### 双链表(double linked list)
```plantuml
[A_0]
[A_1]
[A_2]
[A_3]
[A_4]
[A_5]
A_0->A_1
A_1->A_2
A_2->A_3
A_3->A_4
A_4->A_5
A_5->null
A_1->A_0
A_2->A_1
A_3->A_2
A_4->A_3
A_5->A_4
A_0-left->NULL
```
* 在单链表的形式上多加了一条链
1. 同理删除，添加差不多
2. 查找支持从其中某个节点去查找数据，不限制从头查找

### Java 中实现
&emsp;JAVA集合API，Collections 分别实现了 ArrayList 和 LinkedList 分别是 数组表和 双链表。
&emsp;具体不赘述，就是根据抽象理论的概念从而具现化实现的编码。有时间可能会直接去看JAVA解剖它的源码并总结出来。

# 栈
&emsp; **栈(stack)** 是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，称作 **栈顶(top)**。别称 **LIFO(先进先出)表**
* 对栈的基本操作有 **push(进栈)** 和 **pop(出栈)**, 前者相当于插入，后者相当于删除。
* 对空栈进行 pop 或 top(输出) 操作，一般认为是 栈ADT 中的一个错误。
* 理论上栈模型没有限制大小，实际使用时出现空间用尽是属于一个实现限制。

## 栈的实现
&emsp;栈本来就是一个特殊的表，它是基于表的性质上，做出了一些功能性的限制，例如：限制插入删除，只能对栈顶元素进行操作。从而衍生出的一种全新的表的使用方式。
* 所以栈的实现也分为普通数组实现，链表实现等。

## 栈的应用
### 命令重组
&emsp;将一系列复杂的命令重组为计算机能轻易顺序执行的命令。
#### 后缀表达式
* 假设计算一个运算式的结果：$4.99*1.06+5.99+6.99*1.06=?$
    按照运算法则，应该先算乘法再算加法，但是计算机不懂！
* 所以利用栈的特性去重置这个运算式，重置为：$4.99\ 1.06\ *\ 5.99\ +\ 6.99\ 1.06\ *\ +$，则有以下计算步骤：
    1. 先将**数值**4.99入栈
    2. 第二个**数值**1.06入栈
    3. 乘法**符号**，将前两个值出栈通过乘法符号进行计算
    4. 结果一**数值**5.2894入栈
    5. 第三个**数值**5.99入栈
    6. 加法**符号**，将前两个值出栈通过加法符号进行计算
    7. 结果二**数值**11.2794入栈
    8. 第四个**数值** 6.99 入栈
    9. 第五个**数值** 1.06 入栈
    10. 乘法**符号**，将前两个值出栈通过乘法符号进行计算
    11. 结果三**数值**7.4094入栈
    12. 加法**符号**，将前两个值出栈通过加法符号进行计算
    13. 得到最终结果输出：18.6888
* 这种记法叫做 **后缀(postfix)** 或 **逆波兰(reverse Polish)** 记法。
#### 中缀转后缀
例如上一节的例子中的，运算式的转换。
* 挨个进行读入重组命令：
    1. **数值**4.99，直接输出
    2. 乘法**符号**，入栈
    3. **数值**1.06，直接输出
    4. 乘法**符号**，出栈输出
    5. 加法**符号**，入栈
    6. **数值**5.99，直接输出
    7. 加法**符号**，出栈输出
    8. 加法**符号**，入栈
    9. **数值**6.99，直接输出
    10. 乘法**符号**，入栈
    11. **数值**1.06，直接输出
    12. 乘法**符号**，出栈输出
    13. 加法**符号**, 出栈输出
* 最终结果得到：$4.99\ 1.06\ *\ 5.99\ +\ 6.99\ 1.06\ *\ +$
* 可以思考一下有括号的情况，就把左括号和右括号里面作为一个新的栈进行对应的入栈出栈操作即可(分治)。
### 命令记录回滚
&emsp;将每一步执行的命令都保存在执行过的栈中。进行撤销时，一步一步出栈执行与之对应的逆操作。

### 方法调用
&emsp;JAVA中的方法调用：
* 试做以下想象：
    1. 将JAVA中的方法调用的每个方法想象成，数值的一个加减乘除所结合起来的复合运算。
    2. 抽象出主调例程为最终主要式子（Main方法）。
    3. Main 方法往下所调用的每个方法，都想象成运算式中的一个括号子运算式。
* 显然，所有的全部工作均可由一个栈来完成，而这正是在实现递归的每一种程序设计语言中实际发生的事实。所存储的信息或称为**活动记录(activation record)** 或叫做 **栈帧(stack frame)**。

# 队列
&emsp;像栈一样，**队列(queue)** 也是特殊的表。然而，使用队列时插入在一端进行而删除则再另一端进行。

## 队列的应用
* 例如：
    1. 打印机打印文档
    2. 排队买票
    3. 拨打客服电话
其实因为处理问题的资源有限，为了能使问题最大化的解决，故而采用先到先得的原则进行循环利用已有资源。

# 实际例题
* 给定两个已排序的表 $L_1$ 和 $L_2$, 只使用基本表的操作编写计算 $L_1\cap L_2$和$L_1\cup L_2$
    * 因为只能用表的基础操作
        1. 增加
        2. 删除
        3. 包含
        4. 并
        5. 查找
循环L1去挨个包含或查找L2的元素，然后再决定是合并还是交集。